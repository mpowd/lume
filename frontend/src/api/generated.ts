/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * AI Assistant Platform
 * Platform for creating and managing AI assistants
 * OpenAPI spec version: 2.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './axios-instance';
export type AssistantCreateRequestDescription = string | null;

export interface AssistantCreateRequest {
  name: string;
  description?: AssistantCreateRequestDescription;
  type?: string;
  config: QAAssistantConfig;
  created_by?: string;
}

export interface AssistantResponse {
  id: string;
  name: string;
  description: string;
  type: string;
  config: QAAssistantConfig;
  created_by: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
}

export type AssistantUpdateRequestName = string | null;

export type AssistantUpdateRequestDescription = string | null;

export type AssistantUpdateRequestConfig = QAAssistantConfig | null;

export type AssistantUpdateRequestIsActive = boolean | null;

export interface AssistantUpdateRequest {
  name?: AssistantUpdateRequestName;
  description?: AssistantUpdateRequestDescription;
  config?: AssistantUpdateRequestConfig;
  is_active?: AssistantUpdateRequestIsActive;
}

export interface BodyUploadFilesFileUploadFilesPost {
  collection_name: string;
  files: Blob[];
}

export type CollectionCreateRequestDescription = string | null;

export interface CollectionCreateRequest {
  collection_name: string;
  description?: CollectionCreateRequestDescription;
  embedding_model: string;
  chunk_size: number;
  chunk_overlap: number;
  distance_metric: string;
}

export type DatasetCreationRequestQaPairsItem = { [key: string]: unknown };

export interface DatasetCreationRequest {
  /** Name of the dataset */
  dataset_name: string;
  qa_pairs: DatasetCreationRequestQaPairsItem[];
}

export type DocumentUploadCustomPayload = string | null;

export interface DocumentUpload {
  /**
   * @minLength 1
   * @maxLength 2083
   */
  url: string;
  custom_payload?: DocumentUploadCustomPayload;
}

export interface EnhancedEvaluationRequest {
  /** Name of the evaluation dataset */
  dataset_name: string;
  /** ID of the chatbot used for evaluation */
  chatbot_id: string;
  /** Questions that are evaluated */
  questions: string[];
  /** Ground truth answers for the questions */
  ground_truths: string[];
  /** Answers from the RAG system for the questions */
  answers: string[];
  /** Retrieved context chunks for the questions from the RAG system, each question has a list of context chunks */
  retrieved_contexts: string[][];
}

export interface EvaluateAssistantRequest {
  dataset_name: string;
  assistant_id: string;
  questions: string[];
  ground_truths: string[];
  answers: string[];
  retrieved_contexts: string[][];
  eval_llm_model: string;
  eval_llm_provider: string;
}

export interface EvaluationRequest {
  /** Name of the evaluation dataset */
  dataset_name: string;
  /** Questions that are evaluated */
  questions: string[];
  /** Ground truth answers for the questions */
  ground_truths: string[];
  /** Answers from the RAG system for the questions */
  answers: string[];
  /** Retrieved context chunks for the questions from the RAG system, each question has a list of context chunks */
  retrieved_contexts: string[][];
}

export type ExecutionRequestInputData = { [key: string]: unknown };

/**
 * Request to execute an assistant
 */
export interface ExecutionRequest {
  input_data: ExecutionRequestInputData;
}

export type ExecutionResponseExecutionId = string | null;

export type ExecutionResponseOutput = { [key: string]: unknown };

export type ExecutionResponseExecutionTime = number | null;

export type ExecutionResponseError = string | null;

/**
 * Response from assistant execution
 */
export interface ExecutionResponse {
  execution_id?: ExecutionResponseExecutionId;
  status: string;
  output: ExecutionResponseOutput;
  execution_time?: ExecutionResponseExecutionTime;
  error?: ExecutionResponseError;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type QAAssistantConfigReferencesItem = { [key: string]: unknown };

export type QAAssistantConfigHydePrompt = string | null;

export type QAAssistantConfigRerankerProvider = string | null;

export type QAAssistantConfigRerankerModel = string | null;

export type QAAssistantConfigTopN = number | null;

export type QAAssistantConfigSystemPrompt = string | null;

export type QAAssistantConfigUserPrompt = string | null;

export type QAAssistantConfigPreciseCitationSystemPrompt = string | null;

export type QAAssistantConfigPreciseCitationUserPrompt = string | null;

export type QAAssistantConfigAgenticSystemPrompt = string | null;

/**
 * Configuration for QA Assistant
 */
export interface QAAssistantConfig {
  knowledge_base_ids?: string[];
  opening_message?: string;
  references?: QAAssistantConfigReferencesItem[];
  llm_model?: string;
  llm_provider?: string;
  hybrid_search?: boolean;
  top_k?: number;
  use_hyde?: boolean;
  hyde_prompt?: QAAssistantConfigHydePrompt;
  reranking?: boolean;
  reranker_provider?: QAAssistantConfigRerankerProvider;
  reranker_model?: QAAssistantConfigRerankerModel;
  top_n?: QAAssistantConfigTopN;
  system_prompt?: QAAssistantConfigSystemPrompt;
  user_prompt?: QAAssistantConfigUserPrompt;
  precise_citation?: boolean;
  precise_citation_system_prompt?: QAAssistantConfigPreciseCitationSystemPrompt;
  precise_citation_user_prompt?: QAAssistantConfigPreciseCitationUserPrompt;
  local_only?: boolean;
  tools?: string[];
  max_steps?: number;
  workflow?: string;
  agentic_system_prompt?: QAAssistantConfigAgenticSystemPrompt;
}

export interface RagasDatasetGenerationRequest {
  collection_name: string;
  dataset_name: string;
  /** Number of test cases to generate */
  testset_size?: number;
  /** LLM model to use for generation */
  model_name?: string;
}

export type ValidationErrorLocItem = string | number;

export type ValidationErrorCtx = { [key: string]: unknown };

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
  input?: unknown;
  ctx?: ValidationErrorCtx;
}

export interface BackendApiRoutesKnowledgeBaseUploadDocumentsRequest {
  collection_name: string;
  documents: DocumentUpload[];
}

export interface BackendApiRoutesSourcesWebsiteUploadDocumentsRequest {
  collection_name: string;
  urls: string[];
}

export type ListAssistantsParams = {
/**
 * Filter by assistant type
 */
type?: string | null;
/**
 * Filter by active status
 */
is_active?: boolean | null;
};

export type GetCollectionInfoKnowledgeBaseCollectionInfoGetParams = {
collection_name: string;
};

export type CheckUrlExistsKnowledgeBaseCheckUrlExistsGetParams = {
collection_name: string;
url: string;
};

export type DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams = {
collection_name: string;
};

export type UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams = {
description?: string | null;
};

export type GetLinksWebsiteLinksGetParams = {
/**
 * URL to crawl
 */
base_url: string;
/**
 * Include external domains
 */
include_external_domains?: boolean;
/**
 * Collection name to check for existing URLs
 */
collection_name?: string | null;
};

export type UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody = { [key: string]: unknown };

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Create a new assistant
 * @summary Create Assistant
 */
export const createAssistant = (
    assistantCreateRequest: AssistantCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assistantCreateRequest, signal
    },
      );
    }
  


export const getCreateAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext> => {

const mutationKey = ['createAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssistant>>, {data: AssistantCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAssistant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof createAssistant>>>
    export type CreateAssistantMutationBody = AssistantCreateRequest
    export type CreateAssistantMutationError = HTTPValidationError

    /**
 * @summary Create Assistant
 */
export const useCreateAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createAssistant>>,
        TError,
        {data: AssistantCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all assistants
 * @summary List Assistants
 */
export const listAssistants = (
    params?: ListAssistantsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse[]>(
      {url: `/assistants/`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAssistantsQueryKey = (params?: ListAssistantsParams,) => {
    return [
    `/assistants/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAssistantsQueryOptions = <TData = Awaited<ReturnType<typeof listAssistants>>, TError = HTTPValidationError>(params?: ListAssistantsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAssistantsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAssistants>>> = ({ signal }) => listAssistants(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAssistantsQueryResult = NonNullable<Awaited<ReturnType<typeof listAssistants>>>
export type ListAssistantsQueryError = HTTPValidationError


/**
 * @summary List Assistants
 */

export function useListAssistants<TData = Awaited<ReturnType<typeof listAssistants>>, TError = HTTPValidationError>(
 params?: ListAssistantsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListAssistantsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific assistant
 * @summary Get Assistant
 */
export const getAssistant = (
    assistantId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/${assistantId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAssistantQueryKey = (assistantId?: string,) => {
    return [
    `/assistants/${assistantId}`
    ] as const;
    }

    
export const getGetAssistantQueryOptions = <TData = Awaited<ReturnType<typeof getAssistant>>, TError = HTTPValidationError>(assistantId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssistantQueryKey(assistantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssistant>>> = ({ signal }) => getAssistant(assistantId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assistantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssistantQueryResult = NonNullable<Awaited<ReturnType<typeof getAssistant>>>
export type GetAssistantQueryError = HTTPValidationError


/**
 * @summary Get Assistant
 */

export function useGetAssistant<TData = Awaited<ReturnType<typeof getAssistant>>, TError = HTTPValidationError>(
 assistantId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssistantQueryOptions(assistantId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an assistant
 * @summary Update Assistant
 */
export const updateAssistant = (
    assistantId: string,
    assistantUpdateRequest: AssistantUpdateRequest,
 ) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/${assistantId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assistantUpdateRequest
    },
      );
    }
  


export const getUpdateAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext> => {

const mutationKey = ['updateAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssistant>>, {assistantId: string;data: AssistantUpdateRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  updateAssistant(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssistant>>>
    export type UpdateAssistantMutationBody = AssistantUpdateRequest
    export type UpdateAssistantMutationError = HTTPValidationError

    /**
 * @summary Update Assistant
 */
export const useUpdateAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateAssistant>>,
        TError,
        {assistantId: string;data: AssistantUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete an assistant
 * @summary Delete Assistant
 */
export const deleteAssistant = (
    assistantId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assistants/${assistantId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext> => {

const mutationKey = ['deleteAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssistant>>, {assistantId: string}> = (props) => {
          const {assistantId} = props ?? {};

          return  deleteAssistant(assistantId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssistant>>>
    
    export type DeleteAssistantMutationError = HTTPValidationError

    /**
 * @summary Delete Assistant
 */
export const useDeleteAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssistant>>,
        TError,
        {assistantId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all available assistant types
 * @summary List Assistant Types
 */
export const listAssistantTypes = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/types/list`, method: 'GET', signal
    },
      );
    }
  



export const getListAssistantTypesQueryKey = () => {
    return [
    `/assistants/types/list`
    ] as const;
    }

    
export const getListAssistantTypesQueryOptions = <TData = Awaited<ReturnType<typeof listAssistantTypes>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAssistantTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAssistantTypes>>> = ({ signal }) => listAssistantTypes(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAssistantTypesQueryResult = NonNullable<Awaited<ReturnType<typeof listAssistantTypes>>>
export type ListAssistantTypesQueryError = unknown


/**
 * @summary List Assistant Types
 */

export function useListAssistantTypes<TData = Awaited<ReturnType<typeof listAssistantTypes>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListAssistantTypesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get schemas for a specific assistant type
 * @summary Get Assistant Type Schema
 */
export const getAssistantTypeSchema = (
    assistantType: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/types/${assistantType}/schema`, method: 'GET', signal
    },
      );
    }
  



export const getGetAssistantTypeSchemaQueryKey = (assistantType?: string,) => {
    return [
    `/assistants/types/${assistantType}/schema`
    ] as const;
    }

    
export const getGetAssistantTypeSchemaQueryOptions = <TData = Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError = HTTPValidationError>(assistantType: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssistantTypeSchemaQueryKey(assistantType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssistantTypeSchema>>> = ({ signal }) => getAssistantTypeSchema(assistantType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assistantType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssistantTypeSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof getAssistantTypeSchema>>>
export type GetAssistantTypeSchemaQueryError = HTTPValidationError


/**
 * @summary Get Assistant Type Schema
 */

export function useGetAssistantTypeSchema<TData = Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError = HTTPValidationError>(
 assistantType: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssistantTypeSchemaQueryOptions(assistantType,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Execute an assistant
 * @summary Execute Assistant
 */
export const executeAssistant = (
    assistantId: string,
    executionRequest: ExecutionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ExecutionResponse>(
      {url: `/assistants/${assistantId}/execute`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: executionRequest, signal
    },
      );
    }
  


export const getExecuteAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext> => {

const mutationKey = ['executeAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof executeAssistant>>, {assistantId: string;data: ExecutionRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  executeAssistant(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecuteAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof executeAssistant>>>
    export type ExecuteAssistantMutationBody = ExecutionRequest
    export type ExecuteAssistantMutationError = HTTPValidationError

    /**
 * @summary Execute Assistant
 */
export const useExecuteAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof executeAssistant>>,
        TError,
        {assistantId: string;data: ExecutionRequest},
        TContext
      > => {

      const mutationOptions = getExecuteAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Execute an assistant in streaming mode
 * @summary Execute Assistant Stream
 */
export const executeAssistantStream = (
    assistantId: string,
    executionRequest: ExecutionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/${assistantId}/execute-stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: executionRequest, signal
    },
      );
    }
  


export const getExecuteAssistantStreamMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext> => {

const mutationKey = ['executeAssistantStream'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof executeAssistantStream>>, {assistantId: string;data: ExecutionRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  executeAssistantStream(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecuteAssistantStreamMutationResult = NonNullable<Awaited<ReturnType<typeof executeAssistantStream>>>
    export type ExecuteAssistantStreamMutationBody = ExecutionRequest
    export type ExecuteAssistantStreamMutationError = HTTPValidationError

    /**
 * @summary Execute Assistant Stream
 */
export const useExecuteAssistantStream = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof executeAssistantStream>>,
        TError,
        {assistantId: string;data: ExecutionRequest},
        TContext
      > => {

      const mutationOptions = getExecuteAssistantStreamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get all available collections
 * @summary Get Collections
 */
export const getCollectionsKnowledgeBaseCollectionsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/collections`, method: 'GET', signal
    },
      );
    }
  



export const getGetCollectionsKnowledgeBaseCollectionsGetQueryKey = () => {
    return [
    `/knowledge_base/collections`
    ] as const;
    }

    
export const getGetCollectionsKnowledgeBaseCollectionsGetQueryOptions = <TData = Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollectionsKnowledgeBaseCollectionsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>> = ({ signal }) => getCollectionsKnowledgeBaseCollectionsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCollectionsKnowledgeBaseCollectionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>>
export type GetCollectionsKnowledgeBaseCollectionsGetQueryError = unknown


/**
 * @summary Get Collections
 */

export function useGetCollectionsKnowledgeBaseCollectionsGet<TData = Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionsKnowledgeBaseCollectionsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCollectionsKnowledgeBaseCollectionsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new knowledge base collection with specified configuration.

This creates:
1. A Qdrant collection with the specified vector configuration
2. A MongoDB configuration document with collection metadata and settings
 * @summary Create Collection
 */
export const createCollectionKnowledgeBaseCollectionsPost = (
    collectionCreateRequest: CollectionCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/collections`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: collectionCreateRequest, signal
    },
      );
    }
  


export const getCreateCollectionKnowledgeBaseCollectionsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>, TError,{data: CollectionCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>, TError,{data: CollectionCreateRequest}, TContext> => {

const mutationKey = ['createCollectionKnowledgeBaseCollectionsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>, {data: CollectionCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCollectionKnowledgeBaseCollectionsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollectionKnowledgeBaseCollectionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>>
    export type CreateCollectionKnowledgeBaseCollectionsPostMutationBody = CollectionCreateRequest
    export type CreateCollectionKnowledgeBaseCollectionsPostMutationError = HTTPValidationError

    /**
 * @summary Create Collection
 */
export const useCreateCollectionKnowledgeBaseCollectionsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>, TError,{data: CollectionCreateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createCollectionKnowledgeBaseCollectionsPost>>,
        TError,
        {data: CollectionCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateCollectionKnowledgeBaseCollectionsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get detailed information about a specific collection
 * @summary Get Collection Info
 */
export const getCollectionInfoKnowledgeBaseCollectionInfoGet = (
    params: GetCollectionInfoKnowledgeBaseCollectionInfoGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/collection_info`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetCollectionInfoKnowledgeBaseCollectionInfoGetQueryKey = (params?: GetCollectionInfoKnowledgeBaseCollectionInfoGetParams,) => {
    return [
    `/knowledge_base/collection_info`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetCollectionInfoKnowledgeBaseCollectionInfoGetQueryOptions = <TData = Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>, TError = HTTPValidationError>(params: GetCollectionInfoKnowledgeBaseCollectionInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollectionInfoKnowledgeBaseCollectionInfoGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>> = ({ signal }) => getCollectionInfoKnowledgeBaseCollectionInfoGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCollectionInfoKnowledgeBaseCollectionInfoGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>>
export type GetCollectionInfoKnowledgeBaseCollectionInfoGetQueryError = HTTPValidationError


/**
 * @summary Get Collection Info
 */

export function useGetCollectionInfoKnowledgeBaseCollectionInfoGet<TData = Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>, TError = HTTPValidationError>(
 params: GetCollectionInfoKnowledgeBaseCollectionInfoGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionInfoKnowledgeBaseCollectionInfoGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCollectionInfoKnowledgeBaseCollectionInfoGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload documents to the vector database with duplicate detection and URL normalization.

- collection_name: Name of the collection to add documents to
- documents: List of document objects containing URL and optional custom payload

Performs deduplication at multiple levels:
1. URL normalization - prevents duplicates from http/https, www/non-www variants
2. Document level in MongoDB - prevents duplicate URLs/documents
3. Chunk level in Qdrant - prevents duplicate content chunks
 * @summary Upload Documents
 */
export const uploadDocumentsKnowledgeBaseUploadDocumentsPost = (
    backendApiRoutesKnowledgeBaseUploadDocumentsRequest: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/upload_documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: backendApiRoutesKnowledgeBaseUploadDocumentsRequest, signal
    },
      );
    }
  


export const getUploadDocumentsKnowledgeBaseUploadDocumentsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>, TError,{data: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>, TError,{data: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest}, TContext> => {

const mutationKey = ['uploadDocumentsKnowledgeBaseUploadDocumentsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>, {data: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest}> = (props) => {
          const {data} = props ?? {};

          return  uploadDocumentsKnowledgeBaseUploadDocumentsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadDocumentsKnowledgeBaseUploadDocumentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>>
    export type UploadDocumentsKnowledgeBaseUploadDocumentsPostMutationBody = BackendApiRoutesKnowledgeBaseUploadDocumentsRequest
    export type UploadDocumentsKnowledgeBaseUploadDocumentsPostMutationError = HTTPValidationError

    /**
 * @summary Upload Documents
 */
export const useUploadDocumentsKnowledgeBaseUploadDocumentsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>, TError,{data: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof uploadDocumentsKnowledgeBaseUploadDocumentsPost>>,
        TError,
        {data: BackendApiRoutesKnowledgeBaseUploadDocumentsRequest},
        TContext
      > => {

      const mutationOptions = getUploadDocumentsKnowledgeBaseUploadDocumentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Check if a URL already exists in the specified collection.
Uses URL normalization to handle variants (http/https, www/non-www).

Args:
    collection_name: Name of the collection to check
    url: URL to check for existence

Returns:
    Dict with exists flag and document count
 * @summary Check Url Exists
 */
export const checkUrlExistsKnowledgeBaseCheckUrlExistsGet = (
    params: CheckUrlExistsKnowledgeBaseCheckUrlExistsGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/check_url_exists`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryKey = (params?: CheckUrlExistsKnowledgeBaseCheckUrlExistsGetParams,) => {
    return [
    `/knowledge_base/check_url_exists`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryOptions = <TData = Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>, TError = HTTPValidationError>(params: CheckUrlExistsKnowledgeBaseCheckUrlExistsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>> = ({ signal }) => checkUrlExistsKnowledgeBaseCheckUrlExistsGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type CheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryResult = NonNullable<Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>>
export type CheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryError = HTTPValidationError


/**
 * @summary Check Url Exists
 */

export function useCheckUrlExistsKnowledgeBaseCheckUrlExistsGet<TData = Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>, TError = HTTPValidationError>(
 params: CheckUrlExistsKnowledgeBaseCheckUrlExistsGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof checkUrlExistsKnowledgeBaseCheckUrlExistsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getCheckUrlExistsKnowledgeBaseCheckUrlExistsGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Clean up a collection by removing duplicate documents with the same content
but different URL variants (http/https, www/non-www).

This is useful for collections that were created before URL normalization was implemented.

Args:
    collection_name: Name of the collection to deduplicate

Returns:
    Dict with status and summary of the deduplication process
 * @summary Deduplicate Collection
 */
export const deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost = (
    params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/deduplicate_collection`, method: 'POST',
        params, signal
    },
      );
    }
  


export const getDeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>, TError,{params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>, TError,{params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams}, TContext> => {

const mutationKey = ['deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>, {params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams}> = (props) => {
          const {params} = props ?? {};

          return  deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost(params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostMutationResult = NonNullable<Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>>
    
    export type DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostMutationError = HTTPValidationError

    /**
 * @summary Deduplicate Collection
 */
export const useDeduplicateCollectionKnowledgeBaseDeduplicateCollectionPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>, TError,{params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deduplicateCollectionKnowledgeBaseDeduplicateCollectionPost>>,
        TError,
        {params: DeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostParams},
        TContext
      > => {

      const mutationOptions = getDeduplicateCollectionKnowledgeBaseDeduplicateCollectionPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a collection and all its associated data.

This removes:
1. The Qdrant vector collection
2. The MongoDB document collection
3. The MongoDB configuration document
 * @summary Delete Collection
 */
export const deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete = (
    collectionName: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/collections/${collectionName}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCollectionKnowledgeBaseCollectionsCollectionNameDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>, TError,{collectionName: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>, TError,{collectionName: string}, TContext> => {

const mutationKey = ['deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>, {collectionName: string}> = (props) => {
          const {collectionName} = props ?? {};

          return  deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete(collectionName,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCollectionKnowledgeBaseCollectionsCollectionNameDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>>
    
    export type DeleteCollectionKnowledgeBaseCollectionsCollectionNameDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Collection
 */
export const useDeleteCollectionKnowledgeBaseCollectionsCollectionNameDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>, TError,{collectionName: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteCollectionKnowledgeBaseCollectionsCollectionNameDelete>>,
        TError,
        {collectionName: string},
        TContext
      > => {

      const mutationOptions = getDeleteCollectionKnowledgeBaseCollectionsCollectionNameDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update collection metadata (e.g., description).

Args:
    collection_name: Name of the collection to update
    description: New description for the collection
 * @summary Update Collection
 */
export const updateCollectionKnowledgeBaseCollectionsCollectionNamePatch = (
    collectionName: string,
    params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge_base/collections/${collectionName}`, method: 'PATCH',
        params
    },
      );
    }
  


export const getUpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>, TError,{collectionName: string;params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>, TError,{collectionName: string;params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams}, TContext> => {

const mutationKey = ['updateCollectionKnowledgeBaseCollectionsCollectionNamePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>, {collectionName: string;params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams}> = (props) => {
          const {collectionName,params} = props ?? {};

          return  updateCollectionKnowledgeBaseCollectionsCollectionNamePatch(collectionName,params,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>>
    
    export type UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchMutationError = HTTPValidationError

    /**
 * @summary Update Collection
 */
export const useUpdateCollectionKnowledgeBaseCollectionsCollectionNamePatch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>, TError,{collectionName: string;params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateCollectionKnowledgeBaseCollectionsCollectionNamePatch>>,
        TError,
        {collectionName: string;params?: UpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchParams},
        TContext
      > => {

      const mutationOptions = getUpdateCollectionKnowledgeBaseCollectionsCollectionNamePatchMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get links from a website and mark which ones already exist in the collection.
Returns links with an 'exists_in_collection' flag for URLs that are already in MongoDB.
 * @summary Get Links
 */
export const getLinksWebsiteLinksGet = (
    params: GetLinksWebsiteLinksGetParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/website/links`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetLinksWebsiteLinksGetQueryKey = (params?: GetLinksWebsiteLinksGetParams,) => {
    return [
    `/website/links`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetLinksWebsiteLinksGetQueryOptions = <TData = Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>, TError = HTTPValidationError>(params: GetLinksWebsiteLinksGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLinksWebsiteLinksGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>> = ({ signal }) => getLinksWebsiteLinksGet(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetLinksWebsiteLinksGetQueryResult = NonNullable<Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>>
export type GetLinksWebsiteLinksGetQueryError = HTTPValidationError


/**
 * @summary Get Links
 */

export function useGetLinksWebsiteLinksGet<TData = Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>, TError = HTTPValidationError>(
 params: GetLinksWebsiteLinksGetParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getLinksWebsiteLinksGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetLinksWebsiteLinksGetQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Start website upload task and return task ID
 * @summary Upload Documents
 */
export const uploadDocumentsWebsiteUploadDocumentsPost = (
    backendApiRoutesSourcesWebsiteUploadDocumentsRequest: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/website/upload-documents`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: backendApiRoutesSourcesWebsiteUploadDocumentsRequest, signal
    },
      );
    }
  


export const getUploadDocumentsWebsiteUploadDocumentsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext> => {

const mutationKey = ['uploadDocumentsWebsiteUploadDocumentsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>, {data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}> = (props) => {
          const {data} = props ?? {};

          return  uploadDocumentsWebsiteUploadDocumentsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadDocumentsWebsiteUploadDocumentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>>
    export type UploadDocumentsWebsiteUploadDocumentsPostMutationBody = BackendApiRoutesSourcesWebsiteUploadDocumentsRequest
    export type UploadDocumentsWebsiteUploadDocumentsPostMutationError = HTTPValidationError

    /**
 * @summary Upload Documents
 */
export const useUploadDocumentsWebsiteUploadDocumentsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof uploadDocumentsWebsiteUploadDocumentsPost>>,
        TError,
        {data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest},
        TContext
      > => {

      const mutationOptions = getUploadDocumentsWebsiteUploadDocumentsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get upload progress for a specific website upload task
 * @summary Get Website Upload Progress
 */
export const getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet = (
    taskId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/website/upload-progress/${taskId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryKey = (taskId?: string,) => {
    return [
    `/website/upload-progress/${taskId}`
    ] as const;
    }

    
export const getGetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>, TError = HTTPValidationError>(taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>> = ({ signal }) => getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>>
export type GetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryError = HTTPValidationError


/**
 * @summary Get Website Upload Progress
 */

export function useGetWebsiteUploadProgressWebsiteUploadProgressTaskIdGet<TData = Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWebsiteUploadProgressWebsiteUploadProgressTaskIdGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetWebsiteUploadProgressWebsiteUploadProgressTaskIdGetQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Check if website contents have changed
 * @summary Watch Urls
 */
export const watchUrlsWebsiteWatchUrlsCollectionNameGet = (
    collectionName: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/website/watch_urls/${collectionName}`, method: 'GET', signal
    },
      );
    }
  



export const getWatchUrlsWebsiteWatchUrlsCollectionNameGetQueryKey = (collectionName?: string,) => {
    return [
    `/website/watch_urls/${collectionName}`
    ] as const;
    }

    
export const getWatchUrlsWebsiteWatchUrlsCollectionNameGetQueryOptions = <TData = Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>, TError = HTTPValidationError>(collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWatchUrlsWebsiteWatchUrlsCollectionNameGetQueryKey(collectionName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>> = ({ signal }) => watchUrlsWebsiteWatchUrlsCollectionNameGet(collectionName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(collectionName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>, TError, TData> & { queryKey: QueryKey }
}

export type WatchUrlsWebsiteWatchUrlsCollectionNameGetQueryResult = NonNullable<Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>>
export type WatchUrlsWebsiteWatchUrlsCollectionNameGetQueryError = HTTPValidationError


/**
 * @summary Watch Urls
 */

export function useWatchUrlsWebsiteWatchUrlsCollectionNameGet<TData = Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>, TError = HTTPValidationError>(
 collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof watchUrlsWebsiteWatchUrlsCollectionNameGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getWatchUrlsWebsiteWatchUrlsCollectionNameGetQueryOptions(collectionName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Reindex
 */
export const reindexWebsiteReindexPost = (
    backendApiRoutesSourcesWebsiteUploadDocumentsRequest: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/website/reindex`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: backendApiRoutesSourcesWebsiteUploadDocumentsRequest, signal
    },
      );
    }
  


export const getReindexWebsiteReindexPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexWebsiteReindexPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof reindexWebsiteReindexPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext> => {

const mutationKey = ['reindexWebsiteReindexPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reindexWebsiteReindexPost>>, {data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}> = (props) => {
          const {data} = props ?? {};

          return  reindexWebsiteReindexPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReindexWebsiteReindexPostMutationResult = NonNullable<Awaited<ReturnType<typeof reindexWebsiteReindexPost>>>
    export type ReindexWebsiteReindexPostMutationBody = BackendApiRoutesSourcesWebsiteUploadDocumentsRequest
    export type ReindexWebsiteReindexPostMutationError = HTTPValidationError

    /**
 * @summary Reindex
 */
export const useReindexWebsiteReindexPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexWebsiteReindexPost>>, TError,{data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof reindexWebsiteReindexPost>>,
        TError,
        {data: BackendApiRoutesSourcesWebsiteUploadDocumentsRequest},
        TContext
      > => {

      const mutationOptions = getReindexWebsiteReindexPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Start file upload task and return task ID
 * @summary Upload Files
 */
export const uploadFilesFileUploadFilesPost = (
    bodyUploadFilesFileUploadFilesPost: BodyUploadFilesFileUploadFilesPost,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`collection_name`, bodyUploadFilesFileUploadFilesPost.collection_name)
bodyUploadFilesFileUploadFilesPost.files.forEach(value => formData.append(`files`, value));

      return customInstance<unknown>(
      {url: `/file/upload-files`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadFilesFileUploadFilesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>, TError,{data: BodyUploadFilesFileUploadFilesPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>, TError,{data: BodyUploadFilesFileUploadFilesPost}, TContext> => {

const mutationKey = ['uploadFilesFileUploadFilesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>, {data: BodyUploadFilesFileUploadFilesPost}> = (props) => {
          const {data} = props ?? {};

          return  uploadFilesFileUploadFilesPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadFilesFileUploadFilesPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>>
    export type UploadFilesFileUploadFilesPostMutationBody = BodyUploadFilesFileUploadFilesPost
    export type UploadFilesFileUploadFilesPostMutationError = HTTPValidationError

    /**
 * @summary Upload Files
 */
export const useUploadFilesFileUploadFilesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>, TError,{data: BodyUploadFilesFileUploadFilesPost}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof uploadFilesFileUploadFilesPost>>,
        TError,
        {data: BodyUploadFilesFileUploadFilesPost},
        TContext
      > => {

      const mutationOptions = getUploadFilesFileUploadFilesPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get upload progress for a specific task
 * @summary Get Upload Progress
 */
export const getUploadProgressFileUploadProgressTaskIdGet = (
    taskId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/file/upload-progress/${taskId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUploadProgressFileUploadProgressTaskIdGetQueryKey = (taskId?: string,) => {
    return [
    `/file/upload-progress/${taskId}`
    ] as const;
    }

    
export const getGetUploadProgressFileUploadProgressTaskIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>, TError = HTTPValidationError>(taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUploadProgressFileUploadProgressTaskIdGetQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>> = ({ signal }) => getUploadProgressFileUploadProgressTaskIdGet(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUploadProgressFileUploadProgressTaskIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>>
export type GetUploadProgressFileUploadProgressTaskIdGetQueryError = HTTPValidationError


/**
 * @summary Get Upload Progress
 */

export function useGetUploadProgressFileUploadProgressTaskIdGet<TData = Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUploadProgressFileUploadProgressTaskIdGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUploadProgressFileUploadProgressTaskIdGetQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Serve uploaded files from the data directory
 * @summary Get File
 */
export const getFileFileFilesCollectionNameFilenameGet = (
    collectionName: string,
    filename: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/file/files/${collectionName}/${filename}`, method: 'GET', signal
    },
      );
    }
  



export const getGetFileFileFilesCollectionNameFilenameGetQueryKey = (collectionName?: string,
    filename?: string,) => {
    return [
    `/file/files/${collectionName}/${filename}`
    ] as const;
    }

    
export const getGetFileFileFilesCollectionNameFilenameGetQueryOptions = <TData = Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>, TError = HTTPValidationError>(collectionName: string,
    filename: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileFileFilesCollectionNameFilenameGetQueryKey(collectionName,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>> = ({ signal }) => getFileFileFilesCollectionNameFilenameGet(collectionName,filename, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(collectionName && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFileFileFilesCollectionNameFilenameGetQueryResult = NonNullable<Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>>
export type GetFileFileFilesCollectionNameFilenameGetQueryError = HTTPValidationError


/**
 * @summary Get File
 */

export function useGetFileFileFilesCollectionNameFilenameGet<TData = Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>, TError = HTTPValidationError>(
 collectionName: string,
    filename: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFileFileFilesCollectionNameFilenameGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFileFileFilesCollectionNameFilenameGetQueryOptions(collectionName,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all evaluation datasets.
 * @summary Get Evaluation Datasets
 */
export const getEvaluationDatasetsEvaluationDatasetsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/datasets`, method: 'GET', signal
    },
      );
    }
  



export const getGetEvaluationDatasetsEvaluationDatasetsGetQueryKey = () => {
    return [
    `/evaluation/datasets`
    ] as const;
    }

    
export const getGetEvaluationDatasetsEvaluationDatasetsGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationDatasetsEvaluationDatasetsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>> = ({ signal }) => getEvaluationDatasetsEvaluationDatasetsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEvaluationDatasetsEvaluationDatasetsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>>
export type GetEvaluationDatasetsEvaluationDatasetsGetQueryError = unknown


/**
 * @summary Get Evaluation Datasets
 */

export function useGetEvaluationDatasetsEvaluationDatasetsGet<TData = Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationDatasetsEvaluationDatasetsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetEvaluationDatasetsEvaluationDatasetsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a dataset with manually provided question-answer pairs.

- name: Name of the dataset (as query parameter)
- qa_pairs: List of question-answer pairs (as request body)
 * @summary Create Dataset
 */
export const createDatasetEvaluationDatasetsPost = (
    datasetCreationRequest: DatasetCreationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/datasets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: datasetCreationRequest, signal
    },
      );
    }
  


export const getCreateDatasetEvaluationDatasetsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>, TError,{data: DatasetCreationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>, TError,{data: DatasetCreationRequest}, TContext> => {

const mutationKey = ['createDatasetEvaluationDatasetsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>, {data: DatasetCreationRequest}> = (props) => {
          const {data} = props ?? {};

          return  createDatasetEvaluationDatasetsPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDatasetEvaluationDatasetsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>>
    export type CreateDatasetEvaluationDatasetsPostMutationBody = DatasetCreationRequest
    export type CreateDatasetEvaluationDatasetsPostMutationError = HTTPValidationError

    /**
 * @summary Create Dataset
 */
export const useCreateDatasetEvaluationDatasetsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>, TError,{data: DatasetCreationRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createDatasetEvaluationDatasetsPost>>,
        TError,
        {data: DatasetCreationRequest},
        TContext
      > => {

      const mutationOptions = getCreateDatasetEvaluationDatasetsPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update an evaluation dataset.

- dataset_id: ID of the dataset to update
- update_data: New data to apply to the dataset
 * @summary Update Evaluation Dataset
 */
export const updateEvaluationDatasetEvaluationDatasetsDatasetIdPut = (
    datasetId: string,
    updateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/datasets/${datasetId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody
    },
      );
    }
  


export const getUpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>, TError,{datasetId: string;data: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>, TError,{datasetId: string;data: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody}, TContext> => {

const mutationKey = ['updateEvaluationDatasetEvaluationDatasetsDatasetIdPut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>, {datasetId: string;data: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody}> = (props) => {
          const {datasetId,data} = props ?? {};

          return  updateEvaluationDatasetEvaluationDatasetsDatasetIdPut(datasetId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>>
    export type UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutMutationBody = UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody
    export type UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Evaluation Dataset
 */
export const useUpdateEvaluationDatasetEvaluationDatasetsDatasetIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>, TError,{datasetId: string;data: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateEvaluationDatasetEvaluationDatasetsDatasetIdPut>>,
        TError,
        {datasetId: string;data: UpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutBody},
        TContext
      > => {

      const mutationOptions = getUpdateEvaluationDatasetEvaluationDatasetsDatasetIdPutMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete an evaluation dataset.

- dataset_id: ID of the dataset to delete
 * @summary Delete Dataset
 */
export const deleteDatasetEvaluationDatasetsDatasetIdDelete = (
    datasetId: string,
 ) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/datasets/${datasetId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDatasetEvaluationDatasetsDatasetIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>, TError,{datasetId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>, TError,{datasetId: string}, TContext> => {

const mutationKey = ['deleteDatasetEvaluationDatasetsDatasetIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>, {datasetId: string}> = (props) => {
          const {datasetId} = props ?? {};

          return  deleteDatasetEvaluationDatasetsDatasetIdDelete(datasetId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetEvaluationDatasetsDatasetIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>>
    
    export type DeleteDatasetEvaluationDatasetsDatasetIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDatasetEvaluationDatasetsDatasetIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>, TError,{datasetId: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDatasetEvaluationDatasetsDatasetIdDelete>>,
        TError,
        {datasetId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDatasetEvaluationDatasetsDatasetIdDeleteMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * @summary Generate Ragas Dataset
 */
export const generateRagasDatasetEvaluationRagasPost = (
    ragasDatasetGenerationRequest: RagasDatasetGenerationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/ragas`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ragasDatasetGenerationRequest, signal
    },
      );
    }
  


export const getGenerateRagasDatasetEvaluationRagasPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>, TError,{data: RagasDatasetGenerationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>, TError,{data: RagasDatasetGenerationRequest}, TContext> => {

const mutationKey = ['generateRagasDatasetEvaluationRagasPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>, {data: RagasDatasetGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateRagasDatasetEvaluationRagasPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateRagasDatasetEvaluationRagasPostMutationResult = NonNullable<Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>>
    export type GenerateRagasDatasetEvaluationRagasPostMutationBody = RagasDatasetGenerationRequest
    export type GenerateRagasDatasetEvaluationRagasPostMutationError = HTTPValidationError

    /**
 * @summary Generate Ragas Dataset
 */
export const useGenerateRagasDatasetEvaluationRagasPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>, TError,{data: RagasDatasetGenerationRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof generateRagasDatasetEvaluationRagasPost>>,
        TError,
        {data: RagasDatasetGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGenerateRagasDatasetEvaluationRagasPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Evaluate the RAG system using multiple Ragas metrics including faithfulness and context recall.
 * @summary Evaluate
 */
export const evaluateEvaluationEvaluatePost = (
    evaluationRequest: EvaluationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/evaluate`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: evaluationRequest, signal
    },
      );
    }
  


export const getEvaluateEvaluationEvaluatePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>, TError,{data: EvaluationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>, TError,{data: EvaluationRequest}, TContext> => {

const mutationKey = ['evaluateEvaluationEvaluatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>, {data: EvaluationRequest}> = (props) => {
          const {data} = props ?? {};

          return  evaluateEvaluationEvaluatePost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluateEvaluationEvaluatePostMutationResult = NonNullable<Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>>
    export type EvaluateEvaluationEvaluatePostMutationBody = EvaluationRequest
    export type EvaluateEvaluationEvaluatePostMutationError = HTTPValidationError

    /**
 * @summary Evaluate
 */
export const useEvaluateEvaluationEvaluatePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>, TError,{data: EvaluationRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof evaluateEvaluationEvaluatePost>>,
        TError,
        {data: EvaluationRequest},
        TContext
      > => {

      const mutationOptions = getEvaluateEvaluationEvaluatePostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Evaluate the RAG system using multiple Ragas metrics including faithfulness and context recall.
Also save chatbot information, dataset details, and evaluation results.
 * @summary Evaluate Chatbot
 */
export const evaluateChatbotEvaluationEvaluateChatbotPost = (
    enhancedEvaluationRequest: EnhancedEvaluationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/evaluate-chatbot`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: enhancedEvaluationRequest, signal
    },
      );
    }
  


export const getEvaluateChatbotEvaluationEvaluateChatbotPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>, TError,{data: EnhancedEvaluationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>, TError,{data: EnhancedEvaluationRequest}, TContext> => {

const mutationKey = ['evaluateChatbotEvaluationEvaluateChatbotPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>, {data: EnhancedEvaluationRequest}> = (props) => {
          const {data} = props ?? {};

          return  evaluateChatbotEvaluationEvaluateChatbotPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluateChatbotEvaluationEvaluateChatbotPostMutationResult = NonNullable<Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>>
    export type EvaluateChatbotEvaluationEvaluateChatbotPostMutationBody = EnhancedEvaluationRequest
    export type EvaluateChatbotEvaluationEvaluateChatbotPostMutationError = HTTPValidationError

    /**
 * @summary Evaluate Chatbot
 */
export const useEvaluateChatbotEvaluationEvaluateChatbotPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>, TError,{data: EnhancedEvaluationRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof evaluateChatbotEvaluationEvaluateChatbotPost>>,
        TError,
        {data: EnhancedEvaluationRequest},
        TContext
      > => {

      const mutationOptions = getEvaluateChatbotEvaluationEvaluateChatbotPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve all evaluation results.
 * @summary Get Evaluations
 */
export const getEvaluationsEvaluationEvaluationsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/evaluations`, method: 'GET', signal
    },
      );
    }
  



export const getGetEvaluationsEvaluationEvaluationsGetQueryKey = () => {
    return [
    `/evaluation/evaluations`
    ] as const;
    }

    
export const getGetEvaluationsEvaluationEvaluationsGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationsEvaluationEvaluationsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>> = ({ signal }) => getEvaluationsEvaluationEvaluationsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEvaluationsEvaluationEvaluationsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>>
export type GetEvaluationsEvaluationEvaluationsGetQueryError = unknown


/**
 * @summary Get Evaluations
 */

export function useGetEvaluationsEvaluationEvaluationsGet<TData = Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsEvaluationEvaluationsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetEvaluationsEvaluationEvaluationsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific evaluation by ID.
 * @summary Get Evaluation By Id
 */
export const getEvaluationByIdEvaluationEvaluationsEvaluationIdGet = (
    evaluationId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/evaluations/${evaluationId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryKey = (evaluationId?: string,) => {
    return [
    `/evaluation/evaluations/${evaluationId}`
    ] as const;
    }

    
export const getGetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(evaluationId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryKey(evaluationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>> = ({ signal }) => getEvaluationByIdEvaluationEvaluationsEvaluationIdGet(evaluationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(evaluationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>>
export type GetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryError = HTTPValidationError


/**
 * @summary Get Evaluation By Id
 */

export function useGetEvaluationByIdEvaluationEvaluationsEvaluationIdGet<TData = Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>, TError = HTTPValidationError>(
 evaluationId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationByIdEvaluationEvaluationsEvaluationIdGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetEvaluationByIdEvaluationEvaluationsEvaluationIdGetQueryOptions(evaluationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Evaluate an assistant's performance using RAGAS metrics
 * @summary Evaluate Assistant
 */
export const evaluateAssistantEvaluationEvaluateAssistantPost = (
    evaluateAssistantRequest: EvaluateAssistantRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/evaluate-assistant`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: evaluateAssistantRequest, signal
    },
      );
    }
  


export const getEvaluateAssistantEvaluationEvaluateAssistantPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>, TError,{data: EvaluateAssistantRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>, TError,{data: EvaluateAssistantRequest}, TContext> => {

const mutationKey = ['evaluateAssistantEvaluationEvaluateAssistantPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>, {data: EvaluateAssistantRequest}> = (props) => {
          const {data} = props ?? {};

          return  evaluateAssistantEvaluationEvaluateAssistantPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluateAssistantEvaluationEvaluateAssistantPostMutationResult = NonNullable<Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>>
    export type EvaluateAssistantEvaluationEvaluateAssistantPostMutationBody = EvaluateAssistantRequest
    export type EvaluateAssistantEvaluationEvaluateAssistantPostMutationError = HTTPValidationError

    /**
 * @summary Evaluate Assistant
 */
export const useEvaluateAssistantEvaluationEvaluateAssistantPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>, TError,{data: EvaluateAssistantRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof evaluateAssistantEvaluationEvaluateAssistantPost>>,
        TError,
        {data: EvaluateAssistantRequest},
        TContext
      > => {

      const mutationOptions = getEvaluateAssistantEvaluationEvaluateAssistantPostMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get all evaluations for a specific dataset.
 * @summary Get Evaluations By Dataset
 */
export const getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet = (
    datasetName: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/evaluation/datasets/${datasetName}/evaluations`, method: 'GET', signal
    },
      );
    }
  



export const getGetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryKey = (datasetName?: string,) => {
    return [
    `/evaluation/datasets/${datasetName}/evaluations`
    ] as const;
    }

    
export const getGetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>, TError = HTTPValidationError>(datasetName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryKey(datasetName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>> = ({ signal }) => getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet(datasetName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(datasetName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>>
export type GetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryError = HTTPValidationError


/**
 * @summary Get Evaluations By Dataset
 */

export function useGetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet<TData = Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>, TError = HTTPValidationError>(
 datasetName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetEvaluationsByDatasetEvaluationDatasetsDatasetNameEvaluationsGetQueryOptions(datasetName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Fetch available Ollama models from the host machine
 * @summary Get Ollama Models
 */
export const getOllamaModelsOllamaModelsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/ollama/models`, method: 'GET', signal
    },
      );
    }
  



export const getGetOllamaModelsOllamaModelsGetQueryKey = () => {
    return [
    `/ollama/models`
    ] as const;
    }

    
export const getGetOllamaModelsOllamaModelsGetQueryOptions = <TData = Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOllamaModelsOllamaModelsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>> = ({ signal }) => getOllamaModelsOllamaModelsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOllamaModelsOllamaModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>>
export type GetOllamaModelsOllamaModelsGetQueryError = unknown


/**
 * @summary Get Ollama Models
 */

export function useGetOllamaModelsOllamaModelsGet<TData = Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsOllamaModelsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetOllamaModelsOllamaModelsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Root
 */
export const rootGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/`, method: 'GET', signal
    },
      );
    }
  



export const getRootGetQueryKey = () => {
    return [
    `/`
    ] as const;
    }

    
export const getRootGetQueryOptions = <TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getRootGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof rootGet>>> = ({ signal }) => rootGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData> & { queryKey: QueryKey }
}

export type RootGetQueryResult = NonNullable<Awaited<ReturnType<typeof rootGet>>>
export type RootGetQueryError = unknown


/**
 * @summary Root
 */

export function useRootGet<TData = Awaited<ReturnType<typeof rootGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof rootGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getRootGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Health check endpoint
 * @summary Health Check
 */
export const healthCheckHealthGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  



export const getHealthCheckHealthGetQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthCheckHealthGetQueryOptions = <TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckHealthGet>>> = ({ signal }) => healthCheckHealthGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthCheckHealthGetQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheckHealthGet>>>
export type HealthCheckHealthGetQueryError = unknown


/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<TData = Awaited<ReturnType<typeof healthCheckHealthGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheckHealthGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getHealthCheckHealthGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
