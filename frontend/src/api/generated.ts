/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Lume - AI Assistant Platform
 * Platform for creating and managing AI assistants with RAG
 * OpenAPI spec version: 2.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { customInstance } from './axios-instance';
export type AssistantCreateRequestDescription = string | null;

export interface AssistantCreateRequest {
  name: string;
  description?: AssistantCreateRequestDescription;
  type?: string;
  config: QAAssistantConfig;
  created_by?: string;
}

export interface AssistantResponse {
  id: string;
  name: string;
  description: string;
  type: string;
  config: QAAssistantConfig;
  created_by: string;
  created_at: string;
  updated_at: string;
  is_active: boolean;
}

export type AssistantUpdateRequestName = string | null;

export type AssistantUpdateRequestDescription = string | null;

export type AssistantUpdateRequestConfig = QAAssistantConfig | null;

export type AssistantUpdateRequestIsActive = boolean | null;

export interface AssistantUpdateRequest {
  name?: AssistantUpdateRequestName;
  description?: AssistantUpdateRequestDescription;
  config?: AssistantUpdateRequestConfig;
  is_active?: AssistantUpdateRequestIsActive;
}

export interface BodyUploadFiles {
  collection_name: string;
  files: Blob[];
}

/**
 * The full collection configuration stored in MongoDB.
 */
export interface CollectionConfigResponse {
  collection_name: string;
  description?: string;
  dense_embedding_model: string;
  dense_embedding_dim: number;
  sparse_embedding_model?: string;
  chunk_size: number;
  chunk_overlap: number;
  distance_metric: string;
  created_at: string;
  updated_at: string;
}

export interface CollectionCreateRequest {
  collection_name: string;
  description?: string;
  embedding_model: string;
  chunk_size?: number;
  chunk_overlap?: number;
  distance_metric?: string;
}

export interface CollectionListResponse {
  collection_names: string[];
}

export type CollectionUpdateRequestDescription = string | null;

export interface CollectionUpdateRequest {
  description?: CollectionUpdateRequestDescription;
}

export interface CompletionStatResponse {
  label: string;
  value: number;
  variant?: string;
}

export type DatasetCreateRequestQaPairsItem = { [key: string]: unknown };

export interface DatasetCreateRequest {
  /** Name of the dataset */
  dataset_name: string;
  /** List of question-answer pair dicts */
  qa_pairs: DatasetCreateRequestQaPairsItem[];
}

export interface DatasetListResponse {
  datasets: DatasetResponse[];
}

export type DatasetResponseQaPairsItem = { [key: string]: unknown };

export interface DatasetResponse {
  id: string;
  name: string;
  source_collection: string;
  generated_at: string;
  generator: string;
  model: string;
  num_pairs: number;
  qa_pairs: DatasetResponseQaPairsItem[];
}

export type DatasetUpdateRequestName = string | null;

export type DatasetUpdateRequestQaPairsAnyOfItem = { [key: string]: unknown };

export type DatasetUpdateRequestQaPairs = DatasetUpdateRequestQaPairsAnyOfItem[] | null;

/**
 * Partial update for a dataset. All fields optional.
 */
export interface DatasetUpdateRequest {
  name?: DatasetUpdateRequestName;
  qa_pairs?: DatasetUpdateRequestQaPairs;
}

export interface EvaluateAssistantRequest {
  /** Name of the evaluation dataset */
  dataset_name: string;
  /** ID of the assistant being evaluated */
  assistant_id: string;
  questions: string[];
  ground_truths: string[];
  answers: string[];
  /** Retrieved context chunks per question */
  retrieved_contexts: string[][];
  eval_llm_model?: string;
  eval_llm_provider?: string;
}

export interface EvaluationListResponse {
  evaluations: EvaluationResponse[];
}

export type EvaluationResponseDetailedResultsItem = { [key: string]: unknown };

export interface EvaluationResponse {
  id: string;
  dataset_name: string;
  assistant_id: string;
  eval_llm_model: string;
  eval_llm_provider: string;
  metrics: MetricsSummary;
  detailed_results: EvaluationResponseDetailedResultsItem[];
  created_at: string;
}

export type ExecutionRequestInputData = { [key: string]: unknown };

export interface ExecutionRequest {
  input_data: ExecutionRequestInputData;
}

export type ExecutionResponseExecutionId = string | null;

export type ExecutionResponseOutput = { [key: string]: unknown };

export type ExecutionResponseExecutionTime = number | null;

export type ExecutionResponseError = string | null;

export interface ExecutionResponse {
  execution_id?: ExecutionResponseExecutionId;
  status: string;
  output: ExecutionResponseOutput;
  execution_time?: ExecutionResponseExecutionTime;
  error?: ExecutionResponseError;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export type MetricsSummaryFaithfulness = number | null;

export type MetricsSummaryContextRecall = number | null;

export type MetricsSummaryAnswerRelevancy = number | null;

export type MetricsSummaryContextPrecision = number | null;

export interface MetricsSummary {
  faithfulness?: MetricsSummaryFaithfulness;
  context_recall?: MetricsSummaryContextRecall;
  answer_relevancy?: MetricsSummaryAnswerRelevancy;
  context_precision?: MetricsSummaryContextPrecision;
}

export type ProgressStageResponseCurrentItem = string | null;

export interface ProgressStageResponse {
  label: string;
  current?: number;
  total?: number;
  unit?: string;
  is_current?: boolean;
  current_item?: ProgressStageResponseCurrentItem;
}

export type QAAssistantConfigReferencesItem = { [key: string]: unknown };

export type QAAssistantConfigHydePrompt = string | null;

export type QAAssistantConfigRerankerProvider = string | null;

export type QAAssistantConfigRerankerModel = string | null;

export type QAAssistantConfigTopN = number | null;

export type QAAssistantConfigSystemPrompt = string | null;

export type QAAssistantConfigUserPrompt = string | null;

export type QAAssistantConfigPreciseCitationSystemPrompt = string | null;

export type QAAssistantConfigPreciseCitationUserPrompt = string | null;

export type QAAssistantConfigAgenticSystemPrompt = string | null;

/**
 * Configuration for QA Assistant
 */
export interface QAAssistantConfig {
  knowledge_base_ids?: string[];
  opening_message?: string;
  references?: QAAssistantConfigReferencesItem[];
  llm_model?: string;
  llm_provider?: string;
  hybrid_search?: boolean;
  top_k?: number;
  use_hyde?: boolean;
  hyde_prompt?: QAAssistantConfigHydePrompt;
  reranking?: boolean;
  reranker_provider?: QAAssistantConfigRerankerProvider;
  reranker_model?: QAAssistantConfigRerankerModel;
  top_n?: QAAssistantConfigTopN;
  system_prompt?: QAAssistantConfigSystemPrompt;
  user_prompt?: QAAssistantConfigUserPrompt;
  precise_citation?: boolean;
  precise_citation_system_prompt?: QAAssistantConfigPreciseCitationSystemPrompt;
  precise_citation_user_prompt?: QAAssistantConfigPreciseCitationUserPrompt;
  local_only?: boolean;
  tools?: string[];
  max_steps?: number;
  workflow?: string;
  agentic_system_prompt?: QAAssistantConfigAgenticSystemPrompt;
}

export interface RagasGenerationRequest {
  collection_name: string;
  dataset_name: string;
  /** Number of test cases to generate */
  testset_size?: number;
  /** LLM model for generation */
  model_name?: string;
}

export interface ReindexRequest {
  collection_name: string;
  urls: string[];
}

export interface TaskProgressResponse {
  status: string;
  title: string;
  message: string;
  stages?: ProgressStageResponse[];
  stats?: CompletionStatResponse[];
  failed?: string[];
}

export interface TaskStartedResponse {
  task_id: string;
  message: string;
}

export type ValidationErrorLocItem = string | number;

export type ValidationErrorCtx = { [key: string]: unknown };

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
  input?: unknown;
  ctx?: ValidationErrorCtx;
}

export interface WatchUrlsResponse {
  total_urls: number;
  changed_urls: string[];
  unchanged_urls: string[];
  changed_count: number;
  unchanged_count: number;
}

/**
 * A link discovered during crawling.
 */
export interface WebsiteLinkInfo {
  href: string;
  url: string;
  text?: string;
  title?: string;
  score?: number;
  base_domain?: string;
  exists_in_collection?: boolean;
}

export interface WebsiteUploadRequest {
  collection_name: string;
  urls: string[];
}

export type ListAssistantsParams = {
/**
 * Filter by assistant type
 */
type?: string | null;
/**
 * Filter by active status
 */
is_active?: boolean | null;
};

export type GetWebsiteLinksParams = {
/**
 * URL to crawl for links
 */
base_url: string;
/**
 * Include external domains
 */
include_external?: boolean;
/**
 * Collection to check for existing URLs
 */
collection_name?: string | null;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Create a new assistant
 * @summary Create Assistant
 */
export const createAssistant = (
    assistantCreateRequest: AssistantCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: assistantCreateRequest, signal
    },
      );
    }
  


export const getCreateAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext> => {

const mutationKey = ['createAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAssistant>>, {data: AssistantCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createAssistant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof createAssistant>>>
    export type CreateAssistantMutationBody = AssistantCreateRequest
    export type CreateAssistantMutationError = HTTPValidationError

    /**
 * @summary Create Assistant
 */
export const useCreateAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAssistant>>, TError,{data: AssistantCreateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createAssistant>>,
        TError,
        {data: AssistantCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all assistants
 * @summary List Assistants
 */
export const listAssistants = (
    params?: ListAssistantsParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse[]>(
      {url: `/assistants/`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListAssistantsQueryKey = (params?: ListAssistantsParams,) => {
    return [
    `/assistants/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAssistantsQueryOptions = <TData = Awaited<ReturnType<typeof listAssistants>>, TError = HTTPValidationError>(params?: ListAssistantsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAssistantsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAssistants>>> = ({ signal }) => listAssistants(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAssistantsQueryResult = NonNullable<Awaited<ReturnType<typeof listAssistants>>>
export type ListAssistantsQueryError = HTTPValidationError


/**
 * @summary List Assistants
 */

export function useListAssistants<TData = Awaited<ReturnType<typeof listAssistants>>, TError = HTTPValidationError>(
 params?: ListAssistantsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistants>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListAssistantsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get a specific assistant
 * @summary Get Assistant
 */
export const getAssistant = (
    assistantId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/${assistantId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetAssistantQueryKey = (assistantId?: string,) => {
    return [
    `/assistants/${assistantId}`
    ] as const;
    }

    
export const getGetAssistantQueryOptions = <TData = Awaited<ReturnType<typeof getAssistant>>, TError = HTTPValidationError>(assistantId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssistantQueryKey(assistantId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssistant>>> = ({ signal }) => getAssistant(assistantId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assistantId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssistantQueryResult = NonNullable<Awaited<ReturnType<typeof getAssistant>>>
export type GetAssistantQueryError = HTTPValidationError


/**
 * @summary Get Assistant
 */

export function useGetAssistant<TData = Awaited<ReturnType<typeof getAssistant>>, TError = HTTPValidationError>(
 assistantId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistant>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssistantQueryOptions(assistantId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an assistant
 * @summary Update Assistant
 */
export const updateAssistant = (
    assistantId: string,
    assistantUpdateRequest: AssistantUpdateRequest,
 ) => {
      
      
      return customInstance<AssistantResponse>(
      {url: `/assistants/${assistantId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: assistantUpdateRequest
    },
      );
    }
  


export const getUpdateAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext> => {

const mutationKey = ['updateAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAssistant>>, {assistantId: string;data: AssistantUpdateRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  updateAssistant(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof updateAssistant>>>
    export type UpdateAssistantMutationBody = AssistantUpdateRequest
    export type UpdateAssistantMutationError = HTTPValidationError

    /**
 * @summary Update Assistant
 */
export const useUpdateAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAssistant>>, TError,{assistantId: string;data: AssistantUpdateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateAssistant>>,
        TError,
        {assistantId: string;data: AssistantUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete an assistant
 * @summary Delete Assistant
 */
export const deleteAssistant = (
    assistantId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/assistants/${assistantId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext> => {

const mutationKey = ['deleteAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAssistant>>, {assistantId: string}> = (props) => {
          const {assistantId} = props ?? {};

          return  deleteAssistant(assistantId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAssistant>>>
    
    export type DeleteAssistantMutationError = HTTPValidationError

    /**
 * @summary Delete Assistant
 */
export const useDeleteAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAssistant>>, TError,{assistantId: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteAssistant>>,
        TError,
        {assistantId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all available assistant types
 * @summary List Assistant Types
 */
export const listAssistantTypes = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/types/list`, method: 'GET', signal
    },
      );
    }
  



export const getListAssistantTypesQueryKey = () => {
    return [
    `/assistants/types/list`
    ] as const;
    }

    
export const getListAssistantTypesQueryOptions = <TData = Awaited<ReturnType<typeof listAssistantTypes>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAssistantTypesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAssistantTypes>>> = ({ signal }) => listAssistantTypes(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData> & { queryKey: QueryKey }
}

export type ListAssistantTypesQueryResult = NonNullable<Awaited<ReturnType<typeof listAssistantTypes>>>
export type ListAssistantTypesQueryError = unknown


/**
 * @summary List Assistant Types
 */

export function useListAssistantTypes<TData = Awaited<ReturnType<typeof listAssistantTypes>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listAssistantTypes>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListAssistantTypesQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get schemas for a specific assistant type
 * @summary Get Assistant Type Schema
 */
export const getAssistantTypeSchema = (
    assistantType: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/types/${assistantType}/schema`, method: 'GET', signal
    },
      );
    }
  



export const getGetAssistantTypeSchemaQueryKey = (assistantType?: string,) => {
    return [
    `/assistants/types/${assistantType}/schema`
    ] as const;
    }

    
export const getGetAssistantTypeSchemaQueryOptions = <TData = Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError = HTTPValidationError>(assistantType: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAssistantTypeSchemaQueryKey(assistantType);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssistantTypeSchema>>> = ({ signal }) => getAssistantTypeSchema(assistantType, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(assistantType), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAssistantTypeSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof getAssistantTypeSchema>>>
export type GetAssistantTypeSchemaQueryError = HTTPValidationError


/**
 * @summary Get Assistant Type Schema
 */

export function useGetAssistantTypeSchema<TData = Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError = HTTPValidationError>(
 assistantType: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAssistantTypeSchema>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAssistantTypeSchemaQueryOptions(assistantType,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Execute an assistant
 * @summary Execute Assistant
 */
export const executeAssistant = (
    assistantId: string,
    executionRequest: ExecutionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<ExecutionResponse>(
      {url: `/assistants/${assistantId}/execute`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: executionRequest, signal
    },
      );
    }
  


export const getExecuteAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext> => {

const mutationKey = ['executeAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof executeAssistant>>, {assistantId: string;data: ExecutionRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  executeAssistant(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecuteAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof executeAssistant>>>
    export type ExecuteAssistantMutationBody = ExecutionRequest
    export type ExecuteAssistantMutationError = HTTPValidationError

    /**
 * @summary Execute Assistant
 */
export const useExecuteAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistant>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof executeAssistant>>,
        TError,
        {assistantId: string;data: ExecutionRequest},
        TContext
      > => {

      const mutationOptions = getExecuteAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Execute an assistant in streaming mode
 * @summary Execute Assistant Stream
 */
export const executeAssistantStream = (
    assistantId: string,
    executionRequest: ExecutionRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/assistants/${assistantId}/execute-stream`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: executionRequest, signal
    },
      );
    }
  


export const getExecuteAssistantStreamMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext> => {

const mutationKey = ['executeAssistantStream'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof executeAssistantStream>>, {assistantId: string;data: ExecutionRequest}> = (props) => {
          const {assistantId,data} = props ?? {};

          return  executeAssistantStream(assistantId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExecuteAssistantStreamMutationResult = NonNullable<Awaited<ReturnType<typeof executeAssistantStream>>>
    export type ExecuteAssistantStreamMutationBody = ExecutionRequest
    export type ExecuteAssistantStreamMutationError = HTTPValidationError

    /**
 * @summary Execute Assistant Stream
 */
export const useExecuteAssistantStream = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof executeAssistantStream>>, TError,{assistantId: string;data: ExecutionRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof executeAssistantStream>>,
        TError,
        {assistantId: string;data: ExecutionRequest},
        TContext
      > => {

      const mutationOptions = getExecuteAssistantStreamMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * List all available collections.
 * @summary List Collections
 */
export const listCollections = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<CollectionListResponse>(
      {url: `/knowledge-base/collections`, method: 'GET', signal
    },
      );
    }
  



export const getListCollectionsQueryKey = () => {
    return [
    `/knowledge-base/collections`
    ] as const;
    }

    
export const getListCollectionsQueryOptions = <TData = Awaited<ReturnType<typeof listCollections>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listCollections>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCollectionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCollections>>> = ({ signal }) => listCollections(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCollections>>, TError, TData> & { queryKey: QueryKey }
}

export type ListCollectionsQueryResult = NonNullable<Awaited<ReturnType<typeof listCollections>>>
export type ListCollectionsQueryError = unknown


/**
 * @summary List Collections
 */

export function useListCollections<TData = Awaited<ReturnType<typeof listCollections>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listCollections>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListCollectionsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new knowledge base collection.
 * @summary Create Collection
 */
export const createCollection = (
    collectionCreateRequest: CollectionCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CollectionConfigResponse>(
      {url: `/knowledge-base/collections`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: collectionCreateRequest, signal
    },
      );
    }
  


export const getCreateCollectionMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollection>>, TError,{data: CollectionCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCollection>>, TError,{data: CollectionCreateRequest}, TContext> => {

const mutationKey = ['createCollection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCollection>>, {data: CollectionCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCollection(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof createCollection>>>
    export type CreateCollectionMutationBody = CollectionCreateRequest
    export type CreateCollectionMutationError = HTTPValidationError

    /**
 * @summary Create Collection
 */
export const useCreateCollection = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCollection>>, TError,{data: CollectionCreateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createCollection>>,
        TError,
        {data: CollectionCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateCollectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Get configuration for a specific collection.
 * @summary Get Collection Config
 */
export const getCollectionConfig = (
    collectionName: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<CollectionConfigResponse>(
      {url: `/knowledge-base/collections/${collectionName}`, method: 'GET', signal
    },
      );
    }
  



export const getGetCollectionConfigQueryKey = (collectionName?: string,) => {
    return [
    `/knowledge-base/collections/${collectionName}`
    ] as const;
    }

    
export const getGetCollectionConfigQueryOptions = <TData = Awaited<ReturnType<typeof getCollectionConfig>>, TError = HTTPValidationError>(collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionConfig>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCollectionConfigQueryKey(collectionName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCollectionConfig>>> = ({ signal }) => getCollectionConfig(collectionName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(collectionName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCollectionConfig>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCollectionConfigQueryResult = NonNullable<Awaited<ReturnType<typeof getCollectionConfig>>>
export type GetCollectionConfigQueryError = HTTPValidationError


/**
 * @summary Get Collection Config
 */

export function useGetCollectionConfig<TData = Awaited<ReturnType<typeof getCollectionConfig>>, TError = HTTPValidationError>(
 collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getCollectionConfig>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetCollectionConfigQueryOptions(collectionName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update collection metadata.
 * @summary Update Collection
 */
export const updateCollection = (
    collectionName: string,
    collectionUpdateRequest: CollectionUpdateRequest,
 ) => {
      
      
      return customInstance<void>(
      {url: `/knowledge-base/collections/${collectionName}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: collectionUpdateRequest
    },
      );
    }
  


export const getUpdateCollectionMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollection>>, TError,{collectionName: string;data: CollectionUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCollection>>, TError,{collectionName: string;data: CollectionUpdateRequest}, TContext> => {

const mutationKey = ['updateCollection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCollection>>, {collectionName: string;data: CollectionUpdateRequest}> = (props) => {
          const {collectionName,data} = props ?? {};

          return  updateCollection(collectionName,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof updateCollection>>>
    export type UpdateCollectionMutationBody = CollectionUpdateRequest
    export type UpdateCollectionMutationError = HTTPValidationError

    /**
 * @summary Update Collection
 */
export const useUpdateCollection = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCollection>>, TError,{collectionName: string;data: CollectionUpdateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateCollection>>,
        TError,
        {collectionName: string;data: CollectionUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateCollectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a collection and all associated data.
 * @summary Delete Collection
 */
export const deleteCollection = (
    collectionName: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/knowledge-base/collections/${collectionName}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteCollectionMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollection>>, TError,{collectionName: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteCollection>>, TError,{collectionName: string}, TContext> => {

const mutationKey = ['deleteCollection'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCollection>>, {collectionName: string}> = (props) => {
          const {collectionName} = props ?? {};

          return  deleteCollection(collectionName,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCollectionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCollection>>>
    
    export type DeleteCollectionMutationError = HTTPValidationError

    /**
 * @summary Delete Collection
 */
export const useDeleteCollection = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCollection>>, TError,{collectionName: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteCollection>>,
        TError,
        {collectionName: string},
        TContext
      > => {

      const mutationOptions = getDeleteCollectionMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Discover links from a website and mark existing ones.
 * @summary Get Links
 */
export const getWebsiteLinks = (
    params: GetWebsiteLinksParams,
 signal?: AbortSignal
) => {
      
      
      return customInstance<WebsiteLinkInfo[]>(
      {url: `/knowledge-base/links`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getGetWebsiteLinksQueryKey = (params?: GetWebsiteLinksParams,) => {
    return [
    `/knowledge-base/links`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetWebsiteLinksQueryOptions = <TData = Awaited<ReturnType<typeof getWebsiteLinks>>, TError = HTTPValidationError>(params: GetWebsiteLinksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWebsiteLinks>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWebsiteLinksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWebsiteLinks>>> = ({ signal }) => getWebsiteLinks(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWebsiteLinks>>, TError, TData> & { queryKey: QueryKey }
}

export type GetWebsiteLinksQueryResult = NonNullable<Awaited<ReturnType<typeof getWebsiteLinks>>>
export type GetWebsiteLinksQueryError = HTTPValidationError


/**
 * @summary Get Links
 */

export function useGetWebsiteLinks<TData = Awaited<ReturnType<typeof getWebsiteLinks>>, TError = HTTPValidationError>(
 params: GetWebsiteLinksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getWebsiteLinks>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetWebsiteLinksQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Start background website ingestion. Poll progress via /upload-progress/{task_id}.
 * @summary Upload Websites
 */
export const uploadWebsites = (
    websiteUploadRequest: WebsiteUploadRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TaskStartedResponse>(
      {url: `/knowledge-base/upload-websites`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: websiteUploadRequest, signal
    },
      );
    }
  


export const getUploadWebsitesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadWebsites>>, TError,{data: WebsiteUploadRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadWebsites>>, TError,{data: WebsiteUploadRequest}, TContext> => {

const mutationKey = ['uploadWebsites'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadWebsites>>, {data: WebsiteUploadRequest}> = (props) => {
          const {data} = props ?? {};

          return  uploadWebsites(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadWebsitesMutationResult = NonNullable<Awaited<ReturnType<typeof uploadWebsites>>>
    export type UploadWebsitesMutationBody = WebsiteUploadRequest
    export type UploadWebsitesMutationError = HTTPValidationError

    /**
 * @summary Upload Websites
 */
export const useUploadWebsites = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadWebsites>>, TError,{data: WebsiteUploadRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof uploadWebsites>>,
        TError,
        {data: WebsiteUploadRequest},
        TContext
      > => {

      const mutationOptions = getUploadWebsitesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete and re-ingest URLs.
 * @summary Reindex Urls
 */
export const reindexUrls = (
    reindexRequest: ReindexRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge-base/reindex`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reindexRequest, signal
    },
      );
    }
  


export const getReindexUrlsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexUrls>>, TError,{data: ReindexRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof reindexUrls>>, TError,{data: ReindexRequest}, TContext> => {

const mutationKey = ['reindexUrls'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reindexUrls>>, {data: ReindexRequest}> = (props) => {
          const {data} = props ?? {};

          return  reindexUrls(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReindexUrlsMutationResult = NonNullable<Awaited<ReturnType<typeof reindexUrls>>>
    export type ReindexUrlsMutationBody = ReindexRequest
    export type ReindexUrlsMutationError = HTTPValidationError

    /**
 * @summary Reindex Urls
 */
export const useReindexUrls = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reindexUrls>>, TError,{data: ReindexRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof reindexUrls>>,
        TError,
        {data: ReindexRequest},
        TContext
      > => {

      const mutationOptions = getReindexUrlsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Check if website contents have changed since last scrape.
 * @summary Watch Urls
 */
export const watchUrls = (
    collectionName: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<WatchUrlsResponse>(
      {url: `/knowledge-base/watch-urls/${collectionName}`, method: 'GET', signal
    },
      );
    }
  



export const getWatchUrlsQueryKey = (collectionName?: string,) => {
    return [
    `/knowledge-base/watch-urls/${collectionName}`
    ] as const;
    }

    
export const getWatchUrlsQueryOptions = <TData = Awaited<ReturnType<typeof watchUrls>>, TError = HTTPValidationError>(collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof watchUrls>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getWatchUrlsQueryKey(collectionName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof watchUrls>>> = ({ signal }) => watchUrls(collectionName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(collectionName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof watchUrls>>, TError, TData> & { queryKey: QueryKey }
}

export type WatchUrlsQueryResult = NonNullable<Awaited<ReturnType<typeof watchUrls>>>
export type WatchUrlsQueryError = HTTPValidationError


/**
 * @summary Watch Urls
 */

export function useWatchUrls<TData = Awaited<ReturnType<typeof watchUrls>>, TError = HTTPValidationError>(
 collectionName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof watchUrls>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getWatchUrlsQueryOptions(collectionName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Start background file ingestion. Poll progress via /upload-progress/{task_id}.
 * @summary Upload Files
 */
export const uploadFiles = (
    bodyUploadFiles: BodyUploadFiles,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`collection_name`, bodyUploadFiles.collection_name)
bodyUploadFiles.files.forEach(value => formData.append(`files`, value));

      return customInstance<TaskStartedResponse>(
      {url: `/knowledge-base/upload-files`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getUploadFilesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFiles>>, TError,{data: BodyUploadFiles}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof uploadFiles>>, TError,{data: BodyUploadFiles}, TContext> => {

const mutationKey = ['uploadFiles'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadFiles>>, {data: BodyUploadFiles}> = (props) => {
          const {data} = props ?? {};

          return  uploadFiles(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadFilesMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFiles>>>
    export type UploadFilesMutationBody = BodyUploadFiles
    export type UploadFilesMutationError = HTTPValidationError

    /**
 * @summary Upload Files
 */
export const useUploadFiles = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadFiles>>, TError,{data: BodyUploadFiles}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof uploadFiles>>,
        TError,
        {data: BodyUploadFiles},
        TContext
      > => {

      const mutationOptions = getUploadFilesMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Serve an uploaded file.
 * @summary Get File
 */
export const getFile = (
    collectionName: string,
    filename: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/knowledge-base/files/${collectionName}/${filename}`, method: 'GET', signal
    },
      );
    }
  



export const getGetFileQueryKey = (collectionName?: string,
    filename?: string,) => {
    return [
    `/knowledge-base/files/${collectionName}/${filename}`
    ] as const;
    }

    
export const getGetFileQueryOptions = <TData = Awaited<ReturnType<typeof getFile>>, TError = HTTPValidationError>(collectionName: string,
    filename: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFileQueryKey(collectionName,filename);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFile>>> = ({ signal }) => getFile(collectionName,filename, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(collectionName && filename), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFileQueryResult = NonNullable<Awaited<ReturnType<typeof getFile>>>
export type GetFileQueryError = HTTPValidationError


/**
 * @summary Get File
 */

export function useGetFile<TData = Awaited<ReturnType<typeof getFile>>, TError = HTTPValidationError>(
 collectionName: string,
    filename: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFile>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFileQueryOptions(collectionName,filename,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get progress for a website or file upload task.
 * @summary Get Upload Progress
 */
export const getUploadProgress = (
    taskId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<TaskProgressResponse>(
      {url: `/knowledge-base/upload-progress/${taskId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetUploadProgressQueryKey = (taskId?: string,) => {
    return [
    `/knowledge-base/upload-progress/${taskId}`
    ] as const;
    }

    
export const getGetUploadProgressQueryOptions = <TData = Awaited<ReturnType<typeof getUploadProgress>>, TError = HTTPValidationError>(taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUploadProgress>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUploadProgressQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUploadProgress>>> = ({ signal }) => getUploadProgress(taskId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUploadProgress>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUploadProgressQueryResult = NonNullable<Awaited<ReturnType<typeof getUploadProgress>>>
export type GetUploadProgressQueryError = HTTPValidationError


/**
 * @summary Get Upload Progress
 */

export function useGetUploadProgress<TData = Awaited<ReturnType<typeof getUploadProgress>>, TError = HTTPValidationError>(
 taskId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUploadProgress>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUploadProgressQueryOptions(taskId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve all evaluation datasets.
 * @summary List Datasets
 */
export const listDatasets = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<DatasetListResponse>(
      {url: `/evaluation/datasets`, method: 'GET', signal
    },
      );
    }
  



export const getListDatasetsQueryKey = () => {
    return [
    `/evaluation/datasets`
    ] as const;
    }

    
export const getListDatasetsQueryOptions = <TData = Awaited<ReturnType<typeof listDatasets>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listDatasets>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDatasetsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDatasets>>> = ({ signal }) => listDatasets(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDatasets>>, TError, TData> & { queryKey: QueryKey }
}

export type ListDatasetsQueryResult = NonNullable<Awaited<ReturnType<typeof listDatasets>>>
export type ListDatasetsQueryError = unknown


/**
 * @summary List Datasets
 */

export function useListDatasets<TData = Awaited<ReturnType<typeof listDatasets>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listDatasets>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListDatasetsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a dataset with manually provided QA pairs.
 * @summary Create Dataset
 */
export const createDataset = (
    datasetCreateRequest: DatasetCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DatasetResponse>(
      {url: `/evaluation/datasets`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: datasetCreateRequest, signal
    },
      );
    }
  


export const getCreateDatasetMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataset>>, TError,{data: DatasetCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createDataset>>, TError,{data: DatasetCreateRequest}, TContext> => {

const mutationKey = ['createDataset'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDataset>>, {data: DatasetCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createDataset(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDatasetMutationResult = NonNullable<Awaited<ReturnType<typeof createDataset>>>
    export type CreateDatasetMutationBody = DatasetCreateRequest
    export type CreateDatasetMutationError = HTTPValidationError

    /**
 * @summary Create Dataset
 */
export const useCreateDataset = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDataset>>, TError,{data: DatasetCreateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof createDataset>>,
        TError,
        {data: DatasetCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateDatasetMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update an evaluation dataset.
 * @summary Update Dataset
 */
export const updateDataset = (
    datasetId: string,
    datasetUpdateRequest: DatasetUpdateRequest,
 ) => {
      
      
      return customInstance<DatasetResponse>(
      {url: `/evaluation/datasets/${datasetId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: datasetUpdateRequest
    },
      );
    }
  


export const getUpdateDatasetMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataset>>, TError,{datasetId: string;data: DatasetUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateDataset>>, TError,{datasetId: string;data: DatasetUpdateRequest}, TContext> => {

const mutationKey = ['updateDataset'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDataset>>, {datasetId: string;data: DatasetUpdateRequest}> = (props) => {
          const {datasetId,data} = props ?? {};

          return  updateDataset(datasetId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDatasetMutationResult = NonNullable<Awaited<ReturnType<typeof updateDataset>>>
    export type UpdateDatasetMutationBody = DatasetUpdateRequest
    export type UpdateDatasetMutationError = HTTPValidationError

    /**
 * @summary Update Dataset
 */
export const useUpdateDataset = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDataset>>, TError,{datasetId: string;data: DatasetUpdateRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateDataset>>,
        TError,
        {datasetId: string;data: DatasetUpdateRequest},
        TContext
      > => {

      const mutationOptions = getUpdateDatasetMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete an evaluation dataset.
 * @summary Delete Dataset
 */
export const deleteDataset = (
    datasetId: string,
 ) => {
      
      
      return customInstance<void>(
      {url: `/evaluation/datasets/${datasetId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteDatasetMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataset>>, TError,{datasetId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteDataset>>, TError,{datasetId: string}, TContext> => {

const mutationKey = ['deleteDataset'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDataset>>, {datasetId: string}> = (props) => {
          const {datasetId} = props ?? {};

          return  deleteDataset(datasetId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDatasetMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDataset>>>
    
    export type DeleteDatasetMutationError = HTTPValidationError

    /**
 * @summary Delete Dataset
 */
export const useDeleteDataset = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDataset>>, TError,{datasetId: string}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteDataset>>,
        TError,
        {datasetId: string},
        TContext
      > => {

      const mutationOptions = getDeleteDatasetMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Generate a synthetic QA dataset using RAGAS.
 * @summary Generate Ragas Dataset
 */
export const generateRagasDataset = (
    ragasGenerationRequest: RagasGenerationRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<DatasetResponse>(
      {url: `/evaluation/ragas`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: ragasGenerationRequest, signal
    },
      );
    }
  


export const getGenerateRagasDatasetMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRagasDataset>>, TError,{data: RagasGenerationRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof generateRagasDataset>>, TError,{data: RagasGenerationRequest}, TContext> => {

const mutationKey = ['generateRagasDataset'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof generateRagasDataset>>, {data: RagasGenerationRequest}> = (props) => {
          const {data} = props ?? {};

          return  generateRagasDataset(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GenerateRagasDatasetMutationResult = NonNullable<Awaited<ReturnType<typeof generateRagasDataset>>>
    export type GenerateRagasDatasetMutationBody = RagasGenerationRequest
    export type GenerateRagasDatasetMutationError = HTTPValidationError

    /**
 * @summary Generate Ragas Dataset
 */
export const useGenerateRagasDataset = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof generateRagasDataset>>, TError,{data: RagasGenerationRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof generateRagasDataset>>,
        TError,
        {data: RagasGenerationRequest},
        TContext
      > => {

      const mutationOptions = getGenerateRagasDatasetMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Evaluate an assistant's performance using RAGAS metrics.
 * @summary Evaluate Assistant
 */
export const evaluateAssistant = (
    evaluateAssistantRequest: EvaluateAssistantRequest,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationResponse>(
      {url: `/evaluation/evaluate-assistant`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: evaluateAssistantRequest, signal
    },
      );
    }
  


export const getEvaluateAssistantMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistant>>, TError,{data: EvaluateAssistantRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistant>>, TError,{data: EvaluateAssistantRequest}, TContext> => {

const mutationKey = ['evaluateAssistant'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof evaluateAssistant>>, {data: EvaluateAssistantRequest}> = (props) => {
          const {data} = props ?? {};

          return  evaluateAssistant(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EvaluateAssistantMutationResult = NonNullable<Awaited<ReturnType<typeof evaluateAssistant>>>
    export type EvaluateAssistantMutationBody = EvaluateAssistantRequest
    export type EvaluateAssistantMutationError = HTTPValidationError

    /**
 * @summary Evaluate Assistant
 */
export const useEvaluateAssistant = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof evaluateAssistant>>, TError,{data: EvaluateAssistantRequest}, TContext>, }
 ): UseMutationResult<
        Awaited<ReturnType<typeof evaluateAssistant>>,
        TError,
        {data: EvaluateAssistantRequest},
        TContext
      > => {

      const mutationOptions = getEvaluateAssistantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve all evaluation results.
 * @summary List Evaluations
 */
export const listEvaluations = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationListResponse>(
      {url: `/evaluation/evaluations`, method: 'GET', signal
    },
      );
    }
  



export const getListEvaluationsQueryKey = () => {
    return [
    `/evaluation/evaluations`
    ] as const;
    }

    
export const getListEvaluationsQueryOptions = <TData = Awaited<ReturnType<typeof listEvaluations>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listEvaluations>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEvaluationsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvaluations>>> = ({ signal }) => listEvaluations(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEvaluations>>, TError, TData> & { queryKey: QueryKey }
}

export type ListEvaluationsQueryResult = NonNullable<Awaited<ReturnType<typeof listEvaluations>>>
export type ListEvaluationsQueryError = unknown


/**
 * @summary List Evaluations
 */

export function useListEvaluations<TData = Awaited<ReturnType<typeof listEvaluations>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listEvaluations>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListEvaluationsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Retrieve a specific evaluation by ID.
 * @summary Get Evaluation
 */
export const getEvaluation = (
    evaluationId: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationResponse>(
      {url: `/evaluation/evaluations/${evaluationId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetEvaluationQueryKey = (evaluationId?: string,) => {
    return [
    `/evaluation/evaluations/${evaluationId}`
    ] as const;
    }

    
export const getGetEvaluationQueryOptions = <TData = Awaited<ReturnType<typeof getEvaluation>>, TError = HTTPValidationError>(evaluationId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluation>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetEvaluationQueryKey(evaluationId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getEvaluation>>> = ({ signal }) => getEvaluation(evaluationId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(evaluationId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getEvaluation>>, TError, TData> & { queryKey: QueryKey }
}

export type GetEvaluationQueryResult = NonNullable<Awaited<ReturnType<typeof getEvaluation>>>
export type GetEvaluationQueryError = HTTPValidationError


/**
 * @summary Get Evaluation
 */

export function useGetEvaluation<TData = Awaited<ReturnType<typeof getEvaluation>>, TError = HTTPValidationError>(
 evaluationId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getEvaluation>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetEvaluationQueryOptions(evaluationId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all evaluations for a specific dataset.
 * @summary List Evaluations By Dataset
 */
export const listEvaluationsByDataset = (
    datasetName: string,
 signal?: AbortSignal
) => {
      
      
      return customInstance<EvaluationListResponse>(
      {url: `/evaluation/datasets/${datasetName}/evaluations`, method: 'GET', signal
    },
      );
    }
  



export const getListEvaluationsByDatasetQueryKey = (datasetName?: string,) => {
    return [
    `/evaluation/datasets/${datasetName}/evaluations`
    ] as const;
    }

    
export const getListEvaluationsByDatasetQueryOptions = <TData = Awaited<ReturnType<typeof listEvaluationsByDataset>>, TError = HTTPValidationError>(datasetName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsByDataset>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEvaluationsByDatasetQueryKey(datasetName);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEvaluationsByDataset>>> = ({ signal }) => listEvaluationsByDataset(datasetName, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(datasetName), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsByDataset>>, TError, TData> & { queryKey: QueryKey }
}

export type ListEvaluationsByDatasetQueryResult = NonNullable<Awaited<ReturnType<typeof listEvaluationsByDataset>>>
export type ListEvaluationsByDatasetQueryError = HTTPValidationError


/**
 * @summary List Evaluations By Dataset
 */

export function useListEvaluationsByDataset<TData = Awaited<ReturnType<typeof listEvaluationsByDataset>>, TError = HTTPValidationError>(
 datasetName: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listEvaluationsByDataset>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListEvaluationsByDatasetQueryOptions(datasetName,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Fetch available Ollama models from the host machine
 * @summary Get Ollama Models
 */
export const getOllamaModelsIntegrationsOllamaModelsGet = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/integrations/ollama/models`, method: 'GET', signal
    },
      );
    }
  



export const getGetOllamaModelsIntegrationsOllamaModelsGetQueryKey = () => {
    return [
    `/integrations/ollama/models`
    ] as const;
    }

    
export const getGetOllamaModelsIntegrationsOllamaModelsGetQueryOptions = <TData = Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOllamaModelsIntegrationsOllamaModelsGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>> = ({ signal }) => getOllamaModelsIntegrationsOllamaModelsGet(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>, TError, TData> & { queryKey: QueryKey }
}

export type GetOllamaModelsIntegrationsOllamaModelsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>>
export type GetOllamaModelsIntegrationsOllamaModelsGetQueryError = unknown


/**
 * @summary Get Ollama Models
 */

export function useGetOllamaModelsIntegrationsOllamaModelsGet<TData = Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getOllamaModelsIntegrationsOllamaModelsGet>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetOllamaModelsIntegrationsOllamaModelsGetQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Health Check
 */
export const healthCheck = (
    
 signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/health`, method: 'GET', signal
    },
      );
    }
  



export const getHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: QueryKey }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = unknown


/**
 * @summary Health Check
 */

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>, }
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
